<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.8" xml:lang="en-US">
  <compounddef id="IVFBase_8cuh" kind="file" language="C++">
    <compoundname>IVFBase.cuh</compoundname>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline><highlight class="normal">/*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>Copyright<sp/>(c)<sp/>Meta<sp/>Platforms,<sp/>Inc.<sp/>and<sp/>affiliates.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>This<sp/>source<sp/>code<sp/>is<sp/>licensed<sp/>under<sp/>the<sp/>MIT<sp/>license<sp/>found<sp/>in<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/>*<sp/>LICENSE<sp/>file<sp/>in<sp/>the<sp/>root<sp/>directory<sp/>of<sp/>this<sp/>source<sp/>tree.</highlight></codeline>
<codeline><highlight class="normal"><sp/>*/</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#pragma<sp/>once</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;faiss/Index.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;faiss/MetricType.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;faiss/gpu/GpuIndicesOptions.h&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;faiss/gpu/utils/DeviceTensor.cuh&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;faiss/gpu/utils/DeviceVector.cuh&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;memory&gt;</highlight></codeline>
<codeline><highlight class="normal">#include<sp/>&lt;vector&gt;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">namespace<sp/>faiss<sp/>{</highlight></codeline>
<codeline><highlight class="normal">struct<sp/>InvertedLists;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">namespace<sp/>faiss<sp/>{</highlight></codeline>
<codeline><highlight class="normal">namespace<sp/>gpu<sp/>{</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">class<sp/>GpuResources;</highlight></codeline>
<codeline><highlight class="normal">class<sp/>FlatIndex;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">///<sp/>Base<sp/>inverted<sp/>list<sp/>functionality<sp/>for<sp/>IVFFlat<sp/>and<sp/>IVFPQ</highlight></codeline>
<codeline><highlight class="normal">class<sp/>IVFBase<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>public:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>IVFBase(GpuResources*<sp/>resources,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>dim,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_t<sp/>nlist,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>faiss::MetricType<sp/>metric,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>float<sp/>metricArg,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>interleavedLayout,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>useResidual,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>IndicesOptions<sp/>indicesOptions,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>MemorySpace<sp/>space);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>~IVFBase();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Reserve<sp/>GPU<sp/>memory<sp/>in<sp/>our<sp/>inverted<sp/>lists<sp/>for<sp/>this<sp/>number<sp/>of<sp/>vectors</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>void<sp/>reserveMemory(idx_t<sp/>numVecs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Clear<sp/>out<sp/>all<sp/>inverted<sp/>lists,<sp/>but<sp/>retain<sp/>the<sp/>coarse<sp/>quantizer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>and<sp/>the<sp/>product<sp/>quantizer<sp/>info</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>void<sp/>reset();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Return<sp/>the<sp/>number<sp/>of<sp/>dimensions<sp/>we<sp/>are<sp/>indexing</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>idx_t<sp/>getDim()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>After<sp/>adding<sp/>vectors,<sp/>one<sp/>can<sp/>call<sp/>this<sp/>to<sp/>reclaim<sp/>device<sp/>memory</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>to<sp/>exactly<sp/>the<sp/>amount<sp/>needed.<sp/>Returns<sp/>space<sp/>reclaimed<sp/>in<sp/>bytes</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>size_t<sp/>reclaimMemory();</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Returns<sp/>the<sp/>number<sp/>of<sp/>inverted<sp/>lists</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>idx_t<sp/>getNumLists()<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>For<sp/>debugging<sp/>purposes,<sp/>return<sp/>the<sp/>list<sp/>length<sp/>of<sp/>a<sp/>particular</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>list</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>idx_t<sp/>getListLength(idx_t<sp/>listId)<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Return<sp/>the<sp/>list<sp/>indices<sp/>of<sp/>a<sp/>particular<sp/>list<sp/>back<sp/>to<sp/>the<sp/>CPU</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>std::vector&lt;idx_t&gt;<sp/>getListIndices(idx_t<sp/>listId)<sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Return<sp/>the<sp/>encoded<sp/>vectors<sp/>of<sp/>a<sp/>particular<sp/>list<sp/>back<sp/>to<sp/>the<sp/>CPU</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>std::vector&lt;uint8_t&gt;<sp/>getListVectorData(idx_t<sp/>listId,<sp/>bool<sp/>gpuFormat)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Copy<sp/>all<sp/>inverted<sp/>lists<sp/>from<sp/>a<sp/>CPU<sp/>representation<sp/>to<sp/>ourselves</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>void<sp/>copyInvertedListsFrom(const<sp/>InvertedLists*<sp/>ivf);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Copy<sp/>all<sp/>inverted<sp/>lists<sp/>from<sp/>ourselves<sp/>to<sp/>a<sp/>CPU<sp/>representation</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>void<sp/>copyInvertedListsTo(InvertedLists*<sp/>ivf);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Update<sp/>our<sp/>coarse<sp/>quantizer<sp/>with<sp/>this<sp/>quantizer<sp/>instance;<sp/>may<sp/>be<sp/>a<sp/>CPU</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>or<sp/>GPU<sp/>quantizer</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>void<sp/>updateQuantizer(Index*<sp/>quantizer);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Classify<sp/>and<sp/>encode/add<sp/>vectors<sp/>to<sp/>our<sp/>IVF<sp/>lists.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>The<sp/>input<sp/>data<sp/>must<sp/>be<sp/>on<sp/>our<sp/>current<sp/>device.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Returns<sp/>the<sp/>number<sp/>of<sp/>vectors<sp/>successfully<sp/>added.<sp/>Vectors<sp/>may</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>not<sp/>be<sp/>able<sp/>to<sp/>be<sp/>added<sp/>because<sp/>they<sp/>contain<sp/>NaNs.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>idx_t<sp/>addVectors(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Index*<sp/>coarseQuantizer,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;float,<sp/>2,<sp/>true&gt;&amp;<sp/>vecs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;idx_t,<sp/>1,<sp/>true&gt;&amp;<sp/>indices);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Find<sp/>the<sp/>approximate<sp/>k<sp/>nearest<sp/>neigbors<sp/>for<sp/>`queries`<sp/>against</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>our<sp/>database</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>void<sp/>search(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Index*<sp/>coarseQuantizer,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;float,<sp/>2,<sp/>true&gt;&amp;<sp/>queries,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>nprobe,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>k,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;float,<sp/>2,<sp/>true&gt;&amp;<sp/>outDistances,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;idx_t,<sp/>2,<sp/>true&gt;&amp;<sp/>outIndices)<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Performs<sp/>search<sp/>when<sp/>we<sp/>are<sp/>already<sp/>given<sp/>the<sp/>IVF<sp/>cells<sp/>to<sp/>look<sp/>at</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>(GpuIndexIVF::search_preassigned<sp/>implementation)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>void<sp/>searchPreassigned(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Index*<sp/>coarseQuantizer,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;float,<sp/>2,<sp/>true&gt;&amp;<sp/>vecs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;float,<sp/>2,<sp/>true&gt;&amp;<sp/>ivfDistances,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;idx_t,<sp/>2,<sp/>true&gt;&amp;<sp/>ivfAssignments,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>k,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;float,<sp/>2,<sp/>true&gt;&amp;<sp/>outDistances,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;idx_t,<sp/>2,<sp/>true&gt;&amp;<sp/>outIndices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bool<sp/>storePairs)<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>/*<sp/><sp/>It<sp/>is<sp/>used<sp/>to<sp/>reconstruct<sp/>a<sp/>given<sp/>number<sp/>of<sp/>vectors<sp/>in<sp/>an<sp/>Inverted<sp/>File</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>*<sp/>(IVF)<sp/>index</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/>@param<sp/>i0<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index<sp/>of<sp/>the<sp/>first<sp/>vector<sp/>to<sp/>reconstruct</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/>@param<sp/>n<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>number<sp/>of<sp/>vectors<sp/>to<sp/>reconstruct</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>*<sp/><sp/>@param<sp/>out<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>This<sp/>is<sp/>a<sp/>pointer<sp/>to<sp/>a<sp/>buffer<sp/>where<sp/>the<sp/>reconstructed</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>*<sp/>vectors<sp/>will<sp/>be<sp/>stored.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>*/</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>void<sp/>reconstruct_n(idx_t<sp/>i0,<sp/>idx_t<sp/>n,<sp/>float*<sp/>out);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Adds<sp/>a<sp/>set<sp/>of<sp/>codes<sp/>and<sp/>indices<sp/>to<sp/>a<sp/>list,<sp/>with<sp/>the</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>representation<sp/>coming<sp/>from<sp/>the<sp/>CPU<sp/>equivalent</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>void<sp/>addEncodedVectorsToList_(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_t<sp/>listId,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>resident<sp/>on<sp/>the<sp/>host</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>void*<sp/>codes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>resident<sp/>on<sp/>the<sp/>host</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>idx_t*<sp/>indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_t<sp/>numVecs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Performs<sp/>search<sp/>in<sp/>a<sp/>CPU<sp/>or<sp/>GPU<sp/>coarse<sp/>quantizer<sp/>for<sp/>IVF<sp/>cells,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>returning<sp/>residuals<sp/>as<sp/>well<sp/>if<sp/>necessary</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>searchCoarseQuantizer_(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Index*<sp/>coarseQuantizer,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>int<sp/>nprobe,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>guaranteed<sp/>resident<sp/>on<sp/>device</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;float,<sp/>2,<sp/>true&gt;&amp;<sp/>vecs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Output:<sp/>the<sp/>distances<sp/>to<sp/>the<sp/>closest<sp/>nprobe<sp/>IVF<sp/>cell<sp/>centroids</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>for<sp/>the<sp/>query<sp/>vectors</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>size<sp/>(#vecs,<sp/>nprobe)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;float,<sp/>2,<sp/>true&gt;&amp;<sp/>distances,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>Output:<sp/>the<sp/>closest<sp/>nprobe<sp/>IVF<sp/>cells<sp/>the<sp/>query<sp/>vectors<sp/>lie<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>size<sp/>(#vecs,<sp/>nprobe)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;idx_t,<sp/>2,<sp/>true&gt;&amp;<sp/>indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>optionally<sp/>compute<sp/>the<sp/>residual<sp/>relative<sp/>to<sp/>the<sp/>IVF<sp/>cell<sp/>centroid</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>if<sp/>passed</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>size<sp/>(#vecs,<sp/>nprobe,<sp/>dim)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;float,<sp/>3,<sp/>true&gt;*<sp/>residuals,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>optionally<sp/>return<sp/>the<sp/>IVF<sp/>cell<sp/>centroids<sp/>to<sp/>which<sp/>the<sp/>input</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>vectors<sp/>were<sp/>assigned</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>//<sp/>size<sp/>(#vecs,<sp/>nprobe,<sp/>dim)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;float,<sp/>3,<sp/>true&gt;*<sp/>centroids);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Returns<sp/>the<sp/>number<sp/>of<sp/>bytes<sp/>in<sp/>which<sp/>an<sp/>IVF<sp/>list<sp/>containing<sp/>numVecs</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>vectors<sp/>is<sp/>encoded<sp/>on<sp/>the<sp/>device.<sp/>Note<sp/>that<sp/>due<sp/>to<sp/>padding<sp/>this<sp/>is<sp/>not</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>the<sp/>same<sp/>as<sp/>the<sp/>encoding<sp/>size<sp/>for<sp/>a<sp/>subset<sp/>of<sp/>vectors<sp/>in<sp/>an<sp/>IVF<sp/>list;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>this<sp/>is<sp/>the<sp/>size<sp/>for<sp/>an<sp/>entire<sp/>IVF<sp/>list</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>size_t<sp/>getGpuVectorsEncodingSize_(idx_t<sp/>numVecs)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>size_t<sp/>getCpuVectorsEncodingSize_(idx_t<sp/>numVecs)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Translate<sp/>to<sp/>our<sp/>preferred<sp/>GPU<sp/>encoding</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>std::vector&lt;uint8_t&gt;<sp/>translateCodesToGpu_(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;uint8_t&gt;<sp/>codes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_t<sp/>numVecs)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Translate<sp/>from<sp/>our<sp/>preferred<sp/>GPU<sp/>encoding</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>std::vector&lt;uint8_t&gt;<sp/>translateCodesFromGpu_(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;uint8_t&gt;<sp/>codes,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_t<sp/>numVecs)<sp/>const<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Append<sp/>vectors<sp/>to<sp/>our<sp/>on-device<sp/>lists</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>virtual<sp/>void<sp/>appendVectors_(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;float,<sp/>2,<sp/>true&gt;&amp;<sp/>vecs,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;float,<sp/>2,<sp/>true&gt;&amp;<sp/>ivfCentroidResiduals,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;idx_t,<sp/>1,<sp/>true&gt;&amp;<sp/>indices,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;idx_t,<sp/>1,<sp/>true&gt;&amp;<sp/>uniqueLists,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;idx_t,<sp/>1,<sp/>true&gt;&amp;<sp/>vectorsByUniqueList,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;idx_t,<sp/>1,<sp/>true&gt;&amp;<sp/>uniqueListVectorStart,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;idx_t,<sp/>1,<sp/>true&gt;&amp;<sp/>uniqueListStartOffset,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;idx_t,<sp/>1,<sp/>true&gt;&amp;<sp/>listIds,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Tensor&lt;idx_t,<sp/>1,<sp/>true&gt;&amp;<sp/>listOffset,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStream_t<sp/>stream)<sp/>=<sp/>0;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Reclaim<sp/>memory<sp/>consumed<sp/>on<sp/>the<sp/>device<sp/>for<sp/>our<sp/>inverted<sp/>lists</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>`exact`<sp/>means<sp/>we<sp/>trim<sp/>exactly<sp/>to<sp/>the<sp/>memory<sp/>needed</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>size_t<sp/>reclaimMemory_(bool<sp/>exact);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Update<sp/>all<sp/>device-side<sp/>list<sp/>pointer<sp/>and<sp/>size<sp/>information</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>updateDeviceListInfo_(cudaStream_t<sp/>stream);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>For<sp/>a<sp/>set<sp/>of<sp/>list<sp/>IDs,<sp/>update<sp/>device-side<sp/>list<sp/>pointer<sp/>and<sp/>size</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>information</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>updateDeviceListInfo_(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>const<sp/>std::vector&lt;idx_t&gt;&amp;<sp/>listIds,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaStream_t<sp/>stream);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Shared<sp/>function<sp/>to<sp/>copy<sp/>indices<sp/>from<sp/>CPU<sp/>to<sp/>GPU</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>void<sp/>addIndicesFromCpu_(idx_t<sp/>listId,<sp/>const<sp/>idx_t*<sp/>indices,<sp/>idx_t<sp/>numVecs);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>protected:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Collection<sp/>of<sp/>GPU<sp/>resources<sp/>that<sp/>we<sp/>use</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>GpuResources*<sp/>resources_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Metric<sp/>type<sp/>of<sp/>the<sp/>index</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>faiss::MetricType<sp/>metric_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Metric<sp/>arg</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>float<sp/>metricArg_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Expected<sp/>dimensionality<sp/>of<sp/>the<sp/>vectors</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>int<sp/>dim_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Number<sp/>of<sp/>inverted<sp/>lists<sp/>we<sp/>maintain</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>idx_t<sp/>numLists_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Do<sp/>we<sp/>need<sp/>to<sp/>also<sp/>compute<sp/>residuals<sp/>when<sp/>processing<sp/>vectors?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>useResidual_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Coarse<sp/>quantizer<sp/>centroids<sp/>available<sp/>on<sp/>GPU</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DeviceTensor&lt;float,<sp/>2,<sp/>true&gt;<sp/>ivfCentroids_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Whether<sp/>or<sp/>not<sp/>our<sp/>index<sp/>uses<sp/>an<sp/>interleaved<sp/>by<sp/>kWarpSize<sp/>layout:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>The<sp/>default<sp/>memory<sp/>layout<sp/>is<sp/>[vector][PQ/SQ<sp/>component]:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>(v0<sp/>d0)<sp/>(v0<sp/>d1)<sp/>...<sp/>(v0<sp/>dD-1)<sp/>(v1<sp/>d0)<sp/>(v1<sp/>d1)<sp/>...</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>The<sp/>interleaved<sp/>by<sp/>kWarpSize<sp/>memory<sp/>layout<sp/>is:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>[vector<sp/>/<sp/>kWarpSize][PQ/SQ<sp/>component][vector<sp/>%<sp/>kWarpSize]<sp/>with<sp/>padding:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>(v0<sp/>d0)<sp/>(v1<sp/>d0)<sp/>...<sp/>(v31<sp/>d0)<sp/>(v0<sp/>d1)<sp/>(v1<sp/>d1)<sp/>...<sp/>(v31<sp/>dD-1)<sp/>(v32<sp/>d0)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>(v33<sp/>d0)<sp/>...<sp/>so<sp/>the<sp/>list<sp/>length<sp/>is<sp/>always<sp/>a<sp/>multiple<sp/>of<sp/>num<sp/>quantizers<sp/>*</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>kWarpSize</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>bool<sp/>interleavedLayout_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>How<sp/>are<sp/>user<sp/>indices<sp/>stored<sp/>on<sp/>the<sp/>GPU?</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>IndicesOptions<sp/>indicesOptions_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>What<sp/>memory<sp/>space<sp/>our<sp/>inverted<sp/>list<sp/>storage<sp/>is<sp/>in</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>const<sp/>MemorySpace<sp/>space_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Device<sp/>representation<sp/>of<sp/>all<sp/>inverted<sp/>list<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>id<sp/>-&gt;<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DeviceVector&lt;void*&gt;<sp/>deviceListDataPointers_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Device<sp/>representation<sp/>of<sp/>all<sp/>inverted<sp/>list<sp/>index<sp/>pointers</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>id<sp/>-&gt;<sp/>data</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DeviceVector&lt;void*&gt;<sp/>deviceListIndexPointers_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Device<sp/>representation<sp/>of<sp/>all<sp/>inverted<sp/>list<sp/>lengths</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>id<sp/>-&gt;<sp/>length<sp/>in<sp/>number<sp/>of<sp/>vectors</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>DeviceVector&lt;idx_t&gt;<sp/>deviceListLengths_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Maximum<sp/>list<sp/>length<sp/>seen</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>idx_t<sp/>maxListLength_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>struct<sp/>DeviceIVFList<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DeviceIVFList(GpuResources*<sp/>res,<sp/>const<sp/>AllocInfo&amp;<sp/>info);</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>///<sp/>The<sp/>on-device<sp/>memory<sp/>for<sp/>this<sp/>particular<sp/>IVF<sp/>list</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>DeviceVector&lt;uint8_t&gt;<sp/>data;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>///<sp/>The<sp/>number<sp/>of<sp/>vectors<sp/>encoded<sp/>in<sp/>this<sp/>list,<sp/>which<sp/>may<sp/>be<sp/>unrelated</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>///<sp/>to<sp/>the<sp/>above<sp/>allocated<sp/>data<sp/>size</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>idx_t<sp/>numVecs;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Device<sp/>memory<sp/>for<sp/>each<sp/>separate<sp/>list,<sp/>as<sp/>managed<sp/>by<sp/>the<sp/>host.</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>Device<sp/>memory<sp/>as<sp/>stored<sp/>in<sp/>DeviceVector<sp/>is<sp/>stored<sp/>as<sp/>unique_ptr</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>since<sp/>deviceList*Pointers_<sp/>must<sp/>remain<sp/>valid<sp/>despite</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>resizing<sp/>(and<sp/>potential<sp/>re-allocation)<sp/>of<sp/>deviceList*_</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::unique_ptr&lt;DeviceIVFList&gt;&gt;<sp/>deviceListData_;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::unique_ptr&lt;DeviceIVFList&gt;&gt;<sp/>deviceListIndices_;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>If<sp/>we<sp/>are<sp/>storing<sp/>indices<sp/>on<sp/>the<sp/>CPU<sp/>(indicesOptions_<sp/>is</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>INDICES_CPU),<sp/>then<sp/>this<sp/>maintains<sp/>a<sp/>CPU-side<sp/>map<sp/>of<sp/>what</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>///<sp/>(inverted<sp/>list<sp/>id,<sp/>offset)<sp/>maps<sp/>to<sp/>which<sp/>user<sp/>index</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::vector&lt;idx_t&gt;&gt;<sp/>listOffsetToUserIndex_;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">}<sp/>//<sp/>namespace<sp/>gpu</highlight></codeline>
<codeline><highlight class="normal">}<sp/>//<sp/>namespace<sp/>faiss</highlight></codeline>
    </programlisting>
    <location file="faiss/gpu/impl/IVFBase.cuh"/>
  </compounddef>
</doxygen>
